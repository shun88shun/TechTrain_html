var out_of_memory =
/* tuple */
["Out_of_memory", 0];
var sys_error =
/* tuple */
["Sys_error", -1];
var failure =
/* tuple */
["Failure", -2];
var invalid_argument =
/* tuple */
["Invalid_argument", -3];
var end_of_file =
/* tuple */
["End_of_file", -4];
var division_by_zero =
/* tuple */
["Division_by_zero", -5];
var not_found =
/* tuple */
["Not_found", -6];
var match_failure =
/* tuple */
["Match_failure", -7];
var stack_overflow =
/* tuple */
["Stack_overflow", -8];
var sys_blocked_io =
/* tuple */
["Sys_blocked_io", -9];
var assert_failure =
/* tuple */
["Assert_failure", -10];
var undefined_recursive_module =
/* tuple */
["Undefined_recursive_module", -11];
out_of_memory.tag = 248;
sys_error.tag = 248;
failure.tag = 248;
invalid_argument.tag = 248;
end_of_file.tag = 248;
division_by_zero.tag = 248;
not_found.tag = 248;
match_failure.tag = 248;
stack_overflow.tag = 248;
sys_blocked_io.tag = 248;
assert_failure.tag = 248;
undefined_recursive_module.tag = 248;
/*  Not a pure module */

var undefinedHeader = [];

function some(x) {
  if (x === undefined) {
    var block =
    /* tuple */
    [undefinedHeader, 0];
    block.tag = 256;
    return block;
  }

  if (!(x !== null && x[0] === undefinedHeader)) {
    return x;
  }

  var nid = x[1] + 1 | 0;
  var block$1 =
  /* tuple */
  [undefinedHeader, nid];
  block$1.tag = 256;
  return block$1;
}

function null_to_opt(x) {
  if (x === null) {
    return;
  } else {
    return some(x);
  }
}

function valFromOption(x) {
  if (!(x !== null && x[0] === undefinedHeader)) {
    return x;
  }

  var depth = x[1];

  if (depth === 0) {
    return;
  } else {
    return (
      /* tuple */
      [undefinedHeader, depth - 1 | 0]
    );
  }
}
/* No side effect */

function getWithDefault(opt, $$default) {
  if (opt !== undefined) {
    return valFromOption(opt);
  } else {
    return $$default;
  }
}
/* No side effect */

var float_of_string = function (s, exn) {
  var res = +s;
  if (s.length > 0 && res === res) return res;
  s = s.replace(/_/g, "");
  res = +s;

  if (s.length > 0 && res === res || /^[+-]?nan$/i.test(s)) {
    return res;
  }
  var m = /^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)p([+-]?[0-9]+)/i.exec(s); //            1        2             3           4

  if (m) {
    var m3 = m[3].replace(/0+$/, '');
    var mantissa = parseInt(m[1] + m[2] + m3, 16);
    var exponent = (m[4] | 0) - 4 * m3.length;
    res = mantissa * Math.pow(2, exponent);
    return res;
  }

  if (/^\+?inf(inity)?$/i.test(s)) return Infinity;
  if (/^-inf(inity)?$/i.test(s)) return -Infinity;
  throw exn;
};

function caml_float_of_string(s) {
  return float_of_string(s, [failure, "float_of_string"]);
}
/* No side effect */

// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

function defaultArray(str) {
  return getWithDefault(str, []);
}

function hexParts(t) {
  var match = t.length;

  if (match !== 3) {
    return defaultArray(null_to_opt(t.match(/.{2}/g)));
  } else {
    return defaultArray(null_to_opt(t.match(/.{1}/g))).map(function (x) {
      return x + x;
    });
  }
}

function convert(hex) {
  return hexParts(hex).map(function (x) {
    return caml_float_of_string("0x" + x);
  });
}
/* No side effect */

// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
function hueToRgb(p, q, t) {
  if (t < 1.0 / 6.0) {
    return p + (q - p) * 6.0 * t;
  } else if (t < 0.5) {
    return q;
  } else if (t < 2.0 / 3.0) {
    return p + (q - p) * 6.0 * (2.0 / 3.0 - t);
  } else {
    return p;
  }
}

function createRgbFromHsl(h, s, l) {
  var hue = h / 3.6;
  var tempR = hue + 1.0 / 3.0;
  var tempB = hue - 1.0 / 3.0;
  var q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;
  var p = 2.0 * l - q;
  var b = tempB < 0 ? 0 : tempB;
  return [hueToRgb(p, q, tempR), hueToRgb(p, q, hue), hueToRgb(p, q, b)];
}

function convert$1(hsl) {
  var hsl$1 = hsl.map(function (x) {
    return x / 100.0;
  });
  var tmp;

  if (hsl$1.length !== 3) {
    tmp = [];
  } else {
    var h = hsl$1[0];
    var s = hsl$1[1];

    if (s !== 0.0) {
      var l = hsl$1[2];
      tmp = h === 3.6 ? createRgbFromHsl(0, s, l) : createRgbFromHsl(h, s, l);
    } else {
      var l$1 = hsl$1[2];
      tmp = [l$1, l$1, l$1];
    }
  }

  return tmp.map(function (x) {
    return x * 255.0;
  });
}
/* No side effect */

// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
function removeHash(str) {
  return str.replace("#", "");
}
/* No side effect */

// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
function toSRGB(color) {
  return color / 255.0;
}

function toRGB(color) {
  if (color <= 0.03928) {
    return color / 12.92;
  } else {
    return Math.pow((color + 0.055) / 1.055, 2.4);
  }
}

function relative(rgb) {
  if (rgb.length !== 3) {
    return 0.0;
  }

  var r = rgb[0];
  var g = rgb[1];
  var b = rgb[2];
  return r * 0.2126 + g * 0.7152 + b * 0.0722;
}

function convert$2(color) {
  return relative(color.map(toSRGB).map(toRGB));
}
/* No side effect */

// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

function typeOfColor(color) {
  var match = color.substring(0, 3);

  switch (match) {
    case "hsl":
      return (
        /* HSL */
        0
      );

    case "rgb":
      return (
        /* RGB */
        1
      );

    default:
      return (
        /* HEX */
        2
      );
  }
}

function parseNumbers(rgb) {
  var colors = rgb.match(/\d+/g);

  if (colors !== null) {
    return colors.map(caml_float_of_string);
  } else {
    return [];
  }
}

function parseColor(color) {
  var match = typeOfColor(color);
  var tmp;

  switch (match) {
    case
    /* HSL */
    0:
      tmp = convert$1(parseNumbers(color));
      break;

    case
    /* RGB */
    1:
      tmp = parseNumbers(color);
      break;

    case
    /* HEX */
    2:
      tmp = convert(color);
      break;
  }

  return convert$2(tmp) + 0.05;
}

function calculate(foreground, background) {
  var match = removeHash(foreground);
  var match$1 = removeHash(background);

  if (match === match$1) {
    return 1.0;
  }

  var match$2 = parseColor(match);
  var match$3 = parseColor(match$1);
  return Number((match$2 > match$3 ? match$2 / match$3 : match$3 / match$2).toFixed(2));
}
/* No side effect */

// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

function calculate$1(first, second, background) {
  var firstRatio = calculate(first, background);
  var secondRatio = calculate(second, background);

  if (firstRatio > secondRatio) {
    return first;
  } else {
    return second;
  }
}
/* No side effect */

// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

function calculateFromRatio(ratio) {
  if (ratio >= 7.0) {
    return "AAA";
  } else if (ratio >= 4.5) {
    return "AA";
  } else if (ratio >= 3.0) {
    return "AA Large";
  } else {
    return "Fail";
  }
}

function calculate$2(foreground, background) {
  return calculateFromRatio(calculate(foreground, background));
}
/* No side effect */

// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
var ratio = calculate;
var score = calculate$2;
var scoreFromRatio = calculateFromRatio;
var best = calculate$1;
/* No side effect */

export { best, ratio, score, scoreFromRatio };
